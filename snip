attachCategoryListeners(categoryItem, subMenu) {
    let hoverTimeout;
    
    categoryItem.addEventListener('mouseenter', (event) => {
        // Clear any pending hide timeout
        if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
        }
        
        // Apply hover styles
        Object.assign(categoryItem.style, {
            backgroundColor: '#ECEDF0',
            borderRadius: '6px',
            transition: 'background-color 0.2s ease, border-radius 0.2s ease'
        });
        
        // Initialize submenu
        Object.assign(subMenu.style, {
            display: 'block',
            opacity: '0',
            transform: 'scale(0.95)',
            zIndex: '12000',
            transition: 'opacity 0.3s ease, transform 0.3s ease'
        });
        
        // Position submenu
        this.positionSubMenu(categoryItem, subMenu, event);
        
        // Animate in with shorter delay
        requestAnimationFrame(() => {
            Object.assign(subMenu.style, {
                opacity: '1',
                transform: 'scale(1)'
            });
        });
    });
    
    categoryItem.addEventListener('mouseleave', () => {
        // Add slight delay before hiding to prevent flickering
        hoverTimeout = setTimeout(() => {
            Object.assign(categoryItem.style, {
                backgroundColor: 'transparent',
                borderRadius: '0px'
            });
            
            subMenu.style.display = 'none';
        }, 100);
    });
    
    // Keep submenu open when hovering over it
    subMenu.addEventListener('mouseenter', () => {
        if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
        }
    });
    
    subMenu.addEventListener('mouseleave', () => {
        Object.assign(categoryItem.style, {
            backgroundColor: 'transparent',
            borderRadius: '0px'
        });
        subMenu.style.display = 'none';
    });
}

// Extracted positioning logic for better maintainability
positionSubMenu(categoryItem, subMenu, event) {
    const categoryRect = categoryItem.getBoundingClientRect();
    const subMenuRect = subMenu.getBoundingClientRect();
    const { innerWidth, innerHeight } = window;
    const mouseY = event.clientY;
    
    // Horizontal positioning
    let left = categoryRect.width - 5;
    subMenu.style.right = '';
    
    if (categoryRect.left + left + subMenuRect.width > innerWidth) {
        left = -subMenuRect.width;
    }
    subMenu.style.left = `${left}px`;
    
    // Vertical positioning
    let top = mouseY - categoryRect.top - 40;
    subMenu.style.bottom = '';
    
    let proposedTop = categoryRect.top + top;
    let proposedBottom = proposedTop + subMenuRect.height;
    
    // Adjust if submenu would go below viewport
    if (proposedBottom > innerHeight) {
        top = innerHeight - categoryRect.top - subMenuRect.height - 22;
    }
    
    // Adjust if submenu would go above viewport
    proposedTop = categoryRect.top + top;
    if (proposedTop < 0) {
        top = -categoryRect.top + 5;
    }
    
    subMenu.style.top = `${top}px`;
}
